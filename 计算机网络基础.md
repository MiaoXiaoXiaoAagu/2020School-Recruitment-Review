# 刷题

[搞定计算机网络面试，看这篇就够了（补充版）](https://juejin.im/post/5b7be0b2e51d4538db34a51e)

[面试带你飞：这是一份全面的 计算机网络基础 总结攻略](https://juejin.im/post/5ad7e6c35188252ebd06acfa)

[💗前端需要了解的计算机网络知识， 这一篇就够了！](https://juejin.im/post/5e51febde51d4526c932b390)

[从输入URL到页面展示，你想知道些什么？](https://juejin.im/post/5b148a2ce51d4506965908d2)

## TCP三次握手四次挥手

参考：[TCP连接的建立与释放及SYN Flood介绍](https://blog.csdn.net/fengxinlinux/article/details/81917042)

​			[面试官，不要再问我三次握手和四次挥手](https://juejin.im/post/5d9c284b518825095879e7a5#heading-5)



### 三次握手：

​	**SYN**  (synchronize):	同步序列号，用来发起一个连接。当SYN=1而ACK=0时表明这是一个请求报文段；若对方同意连接，则响应报文中SYN=1，ACK=1

​	**ACK**  (ACKnowledge Character):确认字段，ACK=1时确认，ACK=0时无效

​	**seq**  (sequence): 	发送的数据的第一个字节的序号,之后的数据递增使用序号。此外序号是循环使用的 (TCP是可靠连接，会根据序列号判断是否丢包，然后请求重新传输)

SYN与ACK，请求建立连接并确认，成对出现

seq=x,与ack=x+1 序列号，与确认序列号+1成对出现

![三次握手.png](E:/前端/复习/2020春招复习/img/1)

**三次握手为什么不是两次：**

​	1.如果客户端发送连接请求，服务端接收，两次就建立连接。可能出现以前丢的包，后面发送过来了，然后服务器收到包回应，一回应就建立连接了。

![image-20200305152056791](E:/前端/复习/2020春招复习/img/image-20200305152056791.png)

**三次握手为什么不是四次：** 建立连接是两端的：发送请求-收到回复 ，看起来应该是4次，不过服务端回复客户端的时候带了请求建立连接的信息



**1.1什么是半连接队列**

​		客户端向服务器发送连接请求，此时只完成了三次握手中的第一次，服务器处于`SYN_RCVD`状态，保存了客户端信息到**队列**中，这个队列是**半连接队列**

**1.2 初始序列号，三次握手中发送的seq是固定的吗？ ISN(Initial Sequence Number)**

​	不是，是动态生成的，初始序列号之后的ack=seq+1很容易被猜到（这样就可以伪造服务器和用户建立连接了）

**1.3 SYN攻击是什么**

​	第一次握手时服务端开一个**半连接队列**储连接信息，伪造大量假ip对客户端进行请求的话**半连接队列**会被迅速沾满，队列溢出，真实的用户请求就得不到处理。而且假的用户请求不回完成三次握手，不回复客户端，客户端就会重复发送确认连接信息。

**1.4三次握手过程中可以携带数据吗？**

​	**前两次不行：**syn攻击就是在第一次的时候被假的ip请求占满了**半连接队列**，要是连接没有完成时就可以发送信息的话，遇到攻击的损失会更惨重。**第三次可以：**第三次已经完成连接了所以可以



### 四次挥手

![image.png](.\img\2)

**FIN：**finall   请求断开连接时发送的报文

**1.1为什么挥手是4次**

请求连接需要3次（3次握手），断开需要4次（4次挥手），是因为TCP的**半关闭**造成的。比如客户端请求关闭发送`FIN`，那么收到`ACK`之后就单方断开了，客户端不能向服务端发送数据包，但是服务端可以向客户端继续发送数据包。服务端发送了两次`ACK`，第一次是告诉客户端，发送的`FIN`收到了，第二次是`FIN、ACK`一起发送。客户端、服务端之间每次发送信息都包括了`seq`

**1.2什么是2MSL等待**

如果挥手中第三次、第四次中服务端收到`FIN`回复`ACK`之后马上关闭，若`ACK`丢失就凉了，所以发送`ACK`之后有一个等待时间，等待服务端接收超时再次发送`FIN`



## 五层协议体系结构

![img](.\img\5)

**1.物理层：**物理层是一种标准，解决不同介质（光电）、设备（网线）之间的传输。

**2.数据链路层：**物理层只管在不同介质、设备之间的传递，传递什么并不关心。数据的正误、丢失情况物理层也不管。所以由**数据链路层**负责数据的正确性

​		**数据链路层功能：**

​				**1.封装成帧**

​				**2.透明传输：**封装成帧就有帧头、帧尾的标识，**像ACII的转义字符**一样，要解决帧头帧尾标识出现在数据中的情况。

​				**3.差错控制：**通过特定的编码核对传输信息是否正确

​				**4.差错纠正**

​				**5.流量控制：**发送方发送太快，接收方接收太慢也会导致数据传输出现错误，所以要控制流量

**3.网络层：**

​		**1.数据分块**

​		**2.储存转发**

​		**3.动态分配路线**

**4.传输层：**

## 数据报(网络层)

![img](.\img\3)

首部不带数据的固定长度是20字节`B`，160比特`b`（1字节B=8比特b）

**版本号：**`0-4`比特是版本号：`ipv4/ipv6`

**首部长度：**`4-8`比特是首部长度，最小为5，单位为`4B`,因为首部最少20字节（`20B`）

**目的地址：**目的地址和源地址都是`IP地址`，目的地址是通过`DNS`查询得来的

**片偏移：**数据报长度超过最大限制就会出现分片，片偏移知道自己是第几片，可以重新组合回来



## MAC地址、ARP协议（网络层）

通过`ARP协议`将目的`IP地址`转换为`MAC地址`

生成`ARP列表`，`IP地址`与`MAC地址`相对应

利用`ARP列表`传输数据

在通过`ARP协议`查询`IP地址`对应的`MAC地址`之前会先浏览`ARP列表`是否已经有相关数据

## UDP、TCP（传输层）

### UDP特点

**1.无连接：** 不像TCP一样需要三次握手，四次挥手。UDP首部甚至可以不要源端口号，只管发，不需要收

**2.不可靠：**`最大努力交付`不保证可靠交付，应用层来保证`可靠交付`

**3.面向报文：**UDP对应用程序交下来的报文， 在添加首部后就向下交付给IP层。既不拆分，也不合并，而是保留这些报文的边界， 因此，应用程序需要选择合适的报文大小。

**4.首部小：**只有8字节，TCP20字节，减少网络传输开销

**5.没有拥塞控制：**就算是网络堵塞了也不管，还是发数据

**UDP首部**

![img](.\img\4)

​	**检验和：**检测出首部和数据有错误就直接丢掉

### TCP特点

​	**1.面向连接：**三次握手，四次挥手

​	**2.可靠传输：**可靠有序，不丢不重。

​	**3.面向字节流：**对应用程序交付的数据，大的分块，小的缓存起来

![image-20200306154232297](.\img\image-20200306154232297.png)

[为什么说TCP报文段是面向字节流的，UDP包是面向数据报的？](https://blog.csdn.net/bian_qing_quan11/article/details/77725565)



### TCP如何实现可靠传输

​	**1.校验：**TCP报文头有校验和，用于校验报文是否损坏

​	**2.序号：**TCP报文头的序号

​	**3.确认、重传**：超过一段时间之后还没有收到接收方的确认就会重传



### TCP流量控制：

滑动窗口流量控制

接收方对发送方进行确认收到了哪些数据，并且设置流量窗口。上一个流量窗口的数据发送完之后就根据新的流量窗口大小滑动，已经确认接收的数据销毁。

当滑动窗口为0时，不接收数据。（紧急信息、询问窗口大小等操作除外）



### TCP的拥塞控制：

[计算机网络微课堂第069讲 TCP的拥塞控制](https://www.bilibili.com/video/av83688722?from=search&seid=15487015846130335760)

**基本算法**

​	**1.慢开始：**`拥塞窗口值`从1开始依次*2，达到`慢开始门限值`时停止慢开始算法，开始拥塞避免算法

​	**2.拥塞避免：** 从`慢开始门限`开始，拥塞窗口值每次+1，当出现超时重传时就判断很可能发生了拥塞，将`慢开始门限`调整为此时`拥塞窗口值`**的一半**然后重新从1开始`慢开始`算法



**改进未发生拥塞，但是偶有数据丢失情况**	

​	**1.快重传:**

​	**前提：**接收方接收到了数据之后马上回复，收到了错序的数据之后仍旧回复目前到哪个数据为止时正确的。

​	**例子：**比如接收方收到了1，2，3，5，6，7；收到的1，2，3是有序的，收到5回3；收6回3；收7回3

​				发送方一连返回3个3就知道4丢了，然后发送3给接收方

​				接收方收到4之后凑齐1-7，回复7；发送方继续从8开始发送



​	**2.快恢复**

​	在**快重传**连续收到3个一样的数据确认之后，将之后的`慢开始门限值`设为现在的`拥塞窗口值`的一半，然后开始**拥塞避免算法**(此时跳过了慢开始算法)

![image-20200306170808806](.\img\image-20200306170808806.png)



## HTTP

[面试 -- 网络 HTTP](https://juejin.im/post/5872309261ff4b005c4580d4)

[计算机网络基础：这是一份详细 HTTP 学习指南](https://blog.csdn.net/carson_ho/article/details/82106781)

### 请求报文、响应报文

**请求报文：**

![请求报文](E:\前端\复习\2020春招复习\img\8)

------

**响应报文：**

![响应报文](E:\前端\复习\2020春招复习\img\9)

	### 状态码

常见状态码：[服务器返回的14种常见HTTP状态码](https://blog.csdn.net/q1056843325/article/details/53147180)

![image-20200307154659319](E:\前端\复习\2020春招复习\img\image-20200307154659319.png)

​					200, 204, 301, 302,**304**, 400, 401, 403, 404, 500

### HTTP请求头

[HTTP请求方法详解](https://juejin.im/entry/5b004085f265da0b886daf7c)

HTTP/1.0支持：GET、POST、HEAD三种HTTP请求方法。

HTTP/1.1新增了：OPTIONS、PUT、DELETE、TRACE、CONNECT五种HTTP请求方法。

**检查服务器性能方法：**HEAD、OPTION

​										OPTION可以返回服务器接收的所有方法，HEAD不行



**HTTP请求检查方法：**TRACE

​									TRACE是服务器返回客户端发送的数据，检测HTTP请求是否能正常使用



**修改服务器文件方法：**PUT、DELETE、PATCH

​										PATCH是部分修改，PUT是整体修改一个文件



### POST请求与GET请求的区别：

[都 2019 年了，还问 GET 和 POST 的区别](https://blog.fundebug.com/2019/02/22/compare-http-method-get-and-post/)

[GET 和 POST 到底有什么区别？](https://www.zhihu.com/question/28586791)

[GET和POST区别及缓存问题](https://blog.csdn.net/u012657197/article/details/77541230)

**从浏览器对HTTP协议的实现来看：**

​			**基础概念：幂等**

​								幂等是指的是多次操作的结果是一样的，比如说GET方法就是幂等的，GET进行查询操作，查询1次的结果和查询n的结果都是一样的，不会因为查询多次让服务器数据改变。

​								而post不是幂等的，比如post提交用户信息注册、注册多次得到多个用户，让服务器信息发生了改变。

​			**关于GET的缓存：**由于GET是幂等的，多次GET结果相等，所以处于性能考虑对GET进行缓存。浏览器的刷新对于GET是无害的、GET可以作为书签被收藏。

​			**GET的长度限制：**由于浏览器出于对性能的考虑（解析URL的花销），对URL进行了长度限制



​	**从幂等、缓存考虑，GET、POST区别如下**

| 分类          | GET                    | POST                                                   |
| ------------- | ---------------------- | ------------------------------------------------------ |
| 缓存          | 能被缓存               | 不能缓存                                               |
| 参数保存      | 参数保留在浏览器历史中 | 参数不会保存在浏览器历史中                             |
| 后退按钮/刷新 | 无害                   | 数据会被重新提交（浏览器应该告知用户数据会被重新提交） |
| 书签          | 可收藏为书签           | 不可收藏为书签                                         |



​	**从URL考虑，GET、POST区别如下**

| 分类         | GET                                                | POST                                    |
| ------------ | -------------------------------------------------- | --------------------------------------- |
| 数据类型限制 | 只允许 ASCII 字符                                  | 没有限制,也允许二进制数据。             |
| 数据长度限制 | URL 的长度是受限制的                               | 无限制                                  |
| 安全性       | 数据是 URL 的一部分,与 POST 相比，GET 的安全性较差 | 比GET更好，参数不会被保存在浏览器历史中 |
| 可见性       | 数据在 URL 中对所有人都是可见的                    | 数据不会显示在 URL 中                   |



**从报文上讲，没有本质区别：** 不带参数时只是方法名不同，带参数时一个在url,一个在request body

**常见问题：**

​		**GET 方法参数写法是固定的吗？**

​		以自己约定参数的写法，只要服务端能够解释出来就行，一种比较流行的写法是 	`http://www.example.com/user/name/chengqm/age/22`。



​		**POST 方法比 GET 方法安全？**

​		都是不安全的，因为 HTTP 在网络上是明文传输的，只要在网络节点上捉包，就能完整地获取数据报文。

要想安全传输，就只有加密，也就是 HTTPS。



​		**POST 方法会产生两个 TCP 数据包？**

​		post 会将 header 和 body 分开发送，先发送 header，服务端返回 100 状态码再发送 body。

​		HTTP 协议中没有明确说明 POST 会产生两个 TCP 数据包，而且实际测试(Chrome)发现，header 和 body 不会分开发送。所以，header 和 body 分开发送是部分浏览器或框架的请求方法，不属于 post 必然行为。

#### 三种Content-Type：

​										**application/x-www-form-urlencoded**

​										**multipart/form-data**

​										**application/json**

			### HTTP长连接、短连接

[HTTP长连接和短连接](https://www.cnblogs.com/0201zcr/p/4694945.html)

[菜鸟学网络之 —— 长连接和短连接](https://juejin.im/post/5b010591518825673564cb50#heading-8)

**HTTP协议与TCP/IP协议的关系**

HTTP的长连接和短连接本质上是TCP长连接和短连接。HTTP 1.x协议是**无状态协议**（[HTTP是一个无状态的协议。这句话里的无状态是什么意思？](https://www.zhihu.com/question/23202402)），协议对事务处理能力没有记忆能力，每个请求间是相互独立的。

**Http长连接和TCP长连接的区别**

Http长连接 和 TCP长连接的区别在于: **TCP 的长连接需要自己去维护一套心跳策略。**，而Http只需要在请求头加入`keep-alive:true`即可实现长连接。

## HTTP与HTTPS有什么区别：

[写一篇最好懂的HTTPS讲解](https://blog.csdn.net/guolin_blog/article/details/104546558)

[四分钟搞明白非对称加密](https://www.bilibili.com/video/av65017912?from=search&seid=11308862208074635959)

**对称加密：**对称加密就是收发信息双方用同一种方式加密信息，同一种方式解密信息。（对称加密中只有一套加密解密系统**只有密钥**，**没有公钥、私钥的概念**）



**非对称加密：**非对称加密将密钥分为了公钥和私钥，**！！公钥与私钥可以相互解密，但不能相互推导。**	公钥加密的信息只有私钥可以解密，私钥解密的信息只有公钥可以加密。公钥是公开的，私钥是私有。

​						**例如：**1.服务器持有私钥，发布公钥给浏览器的情况下。服务器使用私钥加密信息，浏览器接收到之后使用公钥解密，能解密就说明是服务器发的。

​									2.浏览器用公钥加密，只有持有私钥的服务器才能解密。



**HTTPS是对称加密与非对称加密的结合：**

​			**无CA机构情况：**

​									**1.对称加密：**浏览器提供对称加密密钥，用于浏览器与服务器之间的沟通。但是由于**第一次传输**密钥的时候是明文，所以不能仅仅使用对称加密。

​									**2.添加非对称加密：**服务器提供公钥，持有私钥。浏览器用公钥解密数据，以确认是服务器发送。 服务器用私钥解密数据，以确保浏览器数据仅自己可见。

​									**3.综合情况：**由于非对称加密消耗性能高，所以非对称加密用于浏览器、服务器第一次交换数据，也就是**传输浏览器生成的密钥——用于之后的对称加密**



​			**添加CA机构：**对称性加密与非对称性加密相结合还是有一个漏洞，服务器**第一次传输**公钥的时候还是会被截取、篡改。就此陷入没法保证第一次传输安全进行的死循环。**此时CA机构加入对网站发放安全性证书**

​					**CA机构**主要功能是为了确保非对称加密的服务器公钥正确。CA机构对**服务器公钥**添加域名、有效时长等信息**制作证书**，然后CA机构用自己的私钥对**证书**进行加密，发放**加密后的证书**给服务器。

​					服务器向浏览器展示自己**加密后的证书**，浏览器**用CA公钥求证**证书可靠性，并且获得非对称加密当中的公钥。

​					**问题：**CA也只有一对公钥，任何被CA私钥加密后的证书都可以被CA公钥解密。用CA公钥可解密只能证明是个证书，但是不能证明是正确服务器的证书。——————>所以CA机构在证书中添加了网站相关信息，以便浏览器确认。

## 输入URL到页面展示发生了什么

[从输入URL到页面展示，你想知道些什么？](https://juejin.im/post/5b148a2ce51d4506965908d2#heading-9)

1. URL输入

2. DNS解析

3. TCP连接

4. 发送HTTP请求

5. 服务器处理请求

6. 服务器响应请求

7. 浏览器解析渲染页面

8. 连接结束


### URL

[URL的组成格式](https://www.jianshu.com/p/2c097bdb121e)

![img](.\img\webp1)

1. protocol 协议：常用
2. hostname 主机地址：域名或ip地址
3. port 端口：http默认80端口
4. path 路径: 网络资源在服务器中的指定路径
5. meter 参数: 如果向服务器中传入参数，在此部分
6. query 查询字符串:
7. fragment 信息片段：

### DNS解析：

**查找顺序： 浏览器缓存--> 操作系统缓存--> 本地host文件 --> 路由器缓存 --> 顶级域名服务器/根域名服务器**



![image-20200306222703835](E:\前端\复习\2020春招复习\img\image-20200306222703835.png)

**查询两种方式**

​	**递归查询：**由DNS客户端**先向局部域名服务器查询**，在局部域名服务器不能回应的情况下——从根域名—>一级域名—>二级域名查询，查询到之后再从二级域名、一级域名、根域名、局部域名服务器这样原路返回。

![img](E:\前端\复习\2020春招复习\img\6)

​	**迭代查询：**![img](E:\前端\复习\2020春招复习\img\7)

## IP地址分类、局域网、子网掩码、网络地址转换NAT（网络层）

[一篇文章带你熟悉 TCP/IP 协议](https://juejin.im/post/5a069b6d51882509e5432656#heading-22)

**1.IP长度**：32位，8位一组，分成4组。（2的8次方=256）

**2.IP组成：**网络标识、主机标识。网络标识标志唯一网址，主机标识在同一网络下具有唯一性，在不同网络下重复

**3.路由：**IP地址运用网络标识进行路由

**4.IP地址分类**

​	**IP分为4组，8位一组，共32位**

​	**IP地址分为4组，也就是A、B、C、D类地址**

​		**A类：**

​				**网络标识：**1-8位为网络标识，也就是第**1**组为网络标识。

​				**首位开头：**0开头

​				**网络地址范围：**0.0.0.0~127.0.0.0        ( 0，2^7-1=127)

​	**B类：**

​				**网络标识：**1-16位为网络标识，也就是前**2**组为网络标识。

​				**首位开头：**10开头

​				**网络地址范围：**128.0.0.0~191.255.0.0        ( 127+1，128+2^6-1=191)

​	**C类：**

​				**网络标识：**1-32位为网络标识，也就是前**3**组为网络标识。

​				**首位开头：**110开头

​				**网络地址范围：**192.0.0.0~223.255.255.0        ( 191+1,192+2^5-1=223)

​	**D类：**

​				**网络标识：**1-8位为网络标识，也就是第**4**组为网络标识。

​				**首位开头：**1110开头

​				**网络地址范围：**224.0.0.0~239.255.255.255        ( 223+1,224+2^4-1=239)

​				D 类地址**没有主机标识**，常用于多播。

​	[TCP/IP协议之单播, 多播, 广播](https://blog.csdn.net/freestyle4568world/article/details/50609435)

![image-20200309235943497](.\img\image-20200309235943497.png)

​	**5.广播地址：**广播地址是专门用于同时向网络中所有工作站进行发送的一个地址。主机标识段host ID 为全1 的IP 地址为广播地址，广播的分组传送给host ID段所涉及的所有计算机。

​						例如，对于10.1.1.0 （255.255.255.0 ）网段，其广播地址为10.1.1.255 （255 即为2 进制的11111111 ），当发出一个目的地址为10.1.1.255 的分组（封包）时，它将被分发给该网段上的所有计算机。

​	

​	**6.多播**：帧仅传送给属于多播组的多个主机。

​				**多播实现原理：**接收多播信息的主机将网卡的工作模式调整为多播，然后从**D类地址**选一个多播地址，只要信息的目的地址是这个**D类地址**，那么就不过滤这些信息。[TCP/IP协议之单播, 多播, 广播](https://blog.csdn.net/freestyle4568world/article/details/50609435)

​	**7.特殊主机号：**主机号全为0表示当前网络段，不可分配为特定主机

​								主机号全为1表示为广播地址，向当前所有网络段所有主机发消息

​	**8.特殊网络号：**

![image-20200309235226181](.\img\image-20200309235226181.png)

![image-20200309235633839](E:\前端\复习\2020春招复习\img\image-20200309235633839.png)

**9.子网掩码：**

​					[详见：《本地视频》.网络层篇-10-5]()

![image-20200310150417418](.\img\image-20200310150417418.png)

​		**作用：**A、B、C类网络地址的划分还不够细，容易造成空间的浪费。子网掩码进行细粒度更小的划分，将A、B、C类中的主机地址分作子网地址.

​		**定义：**与IP长度一样为32位，网络段全为1，主机段全为0。子网掩码是在原来网络段、ip地址的基础上进行**遮掩**划分。 在2进制中，子网验码与ip进行与运算。也就是`1`与二进制中任何数字`与运算`都是那个数字，`0`与二进制中任何数字`与运算`都为`0`。所以0是主机段，1是对原来ip不进行影响的网络段。

​		**例子：**

​				A类地址子网掩码：255.0.0.0

​				B类地址子网掩码：255.255.0.0

​				C类地址子网掩码：255.255.255.0

​				![image-20200310152226296](.\img\image-20200310152226296.png)

​			